package com.eomcs.basic.ex03;

//정수 리터럴 - 정수를 메모리에 저장하는 방법 (2의 보수로 저장)

public class Exam24 {
  public static void main(String[] args) {
    //23
    // => 0000 0000 0000 0000 0000 0000 0001 0111 <2진수 표시법
    System.out.println(23);

    //-23
    // 1) SIGN-MAGNITUDE : 맨 앞비트로 음수 표시
    // => 1000 0000 0000 0000 0000 0000 0001 0111
    // => 23 + (-23) = 0
    // 0000 0000 0000 0000 0000 0000 0001 0111
    // 1000 0000 0000 0000 0000 0000 0001 0111
    //--------------------------------------------
    // 1000 0000 0000 0000 0000 0000 0010 1110 = -46
    // 이 방식은 23 + (-23) = 0 의 결과가 옲게 나오지 않는다.

    // 2) 1'S complement (1의 보수)
    // => 모든 비트를 1이 되는 수로 바꾼다 즉 0을 1로, 1을 0으로 바꾼다
    // 1111 1111 1111 1111 1111 1111 1110 1000 (-23)

    // 0000 0000 0000 0000 0000 0000 0001 0111 (23)
    // 1111 1111 1111 1111 1111 1111 1110 1000 (-23)
    //--------------------------------------------
    // 1111 1111 1111 1111 1111 1111 1111 1111 = 0 이 아니다.
    //+                                      1 <=1을 추가로 더한다
    //------------------------------------------
    //10000 0000 0000 0000 0000 0000 0000 0000 = 0
    //단점 : 음수를 더할떄는 항상 결과에 1를 추가해야 한다.

    // 3) 2's compliment (2의 보수)
    // => 1의 보수의 번거로움을 없애기위해 음수를 저장할때 미리 1을 추가해 두는 방법
    // => 1의 보수 + 1
    //  1111 1111 1111 1111 1111 1111 1110 1001 (-23)

    // 0000 0000 0000 0000 0000 0000 0001 0111 (23)
    // 1111 1111 1111 1111 1111 1111 1110 1001 (-23) = +하기때문에 2는 앞수에 1로 올라감
    //--------------------------------------------
    //10000 0000 0000 0000 0000 0000 0000 0000 = 0





    System.out.println(5);





  }
}