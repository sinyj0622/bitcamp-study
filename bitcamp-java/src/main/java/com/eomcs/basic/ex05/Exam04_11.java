// 비트 이동 연산자 : 비트 이동의 유효 범위
package com.eomcs.basic.ex05;

public class Exam04_11 {
    public static void main(String[] args) {


      System.out.println(3 << 1);
      //    0000000 00000000 00000000 000000011 = 3     
      //  0|0000000 00000000 00000000 00000011x = 비트이동 
      //    0000000 00000000 00000000 000000110 = 6  
        
      System.out.println(3 << 33); // 6
      System.out.println(3 << 65); // 6
      System.out.println(3 << 97); // 6
      
      // 3 에 33 비트를 이동하나, 65비트를 이동하나, 97비트를 이동하나
      // 같은 값이 나오는 이유??
      // => int 타입의 값에 대해 비트 이동을 할 때는  0 ~ 31 까지만 유효하다
      //    만약 31을 넘는 경우 32로 나눈 나머지 값을 비트 이동으로 간주한다.
      // => long 타입의 경우 비트 이동은  0 ~ 63까지 유효하다.
      //    만약 63을 넘는 경우 64로 나눈 나머지 값을 비트 이동으로 간주한다.
      
      
      // int 값에 대한 비트 이동은 할 때 0 ~ 31 이다.
      // long 값에 대해 비트 이동을 할 때 0 ~ 63 이다.
      // 비트 이동 유효 범위를 벗어난다면 
      //=> int 데이터인 경우 비트 이동 값은 '하위 5비트만 유효'하다.
      //=> long 데이터인 경우 비트 이동 값은 하위 6비트만 유효하다.
      
      //=> 공식:
      //  n << s
      //  - n = int 타입이라면, 다음 계산을 통해 s의 최종 값을 결정한다. 하위 5비트만 취한다.
      //    s & 0b11111 = 최종 비트 이동 값 
      //    따라서 s의 값은 무조건 0 ~ 31이다.
      //    ***결국 s의 값은 s % 32 의 결과와 같다.
      //  - n = long 타입이라면,다음 계산을 통해 s의 최종 값을 결정한다. 하위 6비트만 취한다.
      //    s & 0b111111 = 비트 이동
      //    따라서 s의 값은 무조건 0 ~ 63이다.
      //    ***결국 s의 값은 s % 64 의 결과와 같다.

      
      // => 예1)
      //    3 << 33
      //    n = 00000000 00000000 00000000 00000011 = 3
      //    s = 00000000 00000000 00000000 00100001 = 33
      //    비트이동 = s & 0b11111 (하위 5비트만 유효하다.)
      //        00000000 00000000 00000000 00100001 = 33
      //      & 00000000 00000000 00000000 00011111 = 
      //       --------------------------------------
      //        00000000 00000000 00000000 00000001 = 1   (&=둘다 1일때만 1이다)
      //      최종 비트 이동 값을 계산하면 다음과 같다.
      //        3 << 33 == 3 << 1
      //    
      //
      // => 예2)
      //    3 << 65
      //    n = 00000000 00000000 00000000 00000011 = 3
      //    s = 00000000 00000000 00000000 01000001 = 65
      //    비트이동 = s & 0b111111 (하위 6비트만 유효하다.)
      //        00000000 00000000 00000000 01000001 = 33
      //      & 00000000 00000000 00000000 00111111 = 
      //       --------------------------------------
      //        00000000 00000000 00000000 00000001 = 1   (&=둘다 1일때만 1이다)
      //      최종 비트 이동 값을 계산하면 다음과 같다.
      //        3 << 65 == 3 << 1     
      //    비트 이동 계산의 근거 : java Language Specification 참고,,,
      
      
      
    }
}

// 왼쪽 이동
// - 1비트 이동은 곱하기 2 한 것과 같은 효과를 준다.
// - 값을 배수로 증가 시킬때 곱하기 연산보다 왼쪽 비트이동 연산이 빠르기 때문에 실무에서는 배수 연산을
//   수행할때 비트이동 연산을 자주 사용한다